# 技术方案

这里有张图。

UniSign实际上是使用一个第三方服务器作为交易信息的中间存储。DApp在发送需要签名的交易信息给服务器后，服务器给DApp返回一个查询API的地址。DApp再将这个地址通过二维码提供给用户，由用户（Neuron）进行签名，再发送到区块链。

Neuron在发送签名后的交易得到交易哈希之后，将交易哈希和交易状态，通过服务器中介，返回给DApp端。

## 安全解决方案
我们提前预想了几种可能会出现的安全问题，并提出了对应的解决方案。

&emsp;&emsp;时至今日，快速响应码（Quick Response Code），也就是我们常说的二维码似乎已经渗透到我们生活的每个角落。扫一扫添加好友或公众号、扫码参与活动、扫码支付、扫码登录……移动设备日渐普及，除非脱离社会，很难想象一个人的生活里没有二维码的存在。二维码的广泛应用确实极大地便利了人们的生活，但这又不得不使我们开始思考二维码应用中的安全问题。<br>
## 钓鱼二维码
&emsp;&emsp;日常生活中支付宝、微信付款码和收款码涉及用户资产，淘宝微信扫码登录涉及用户数据，安全问题在这些领域理应受到更多的关注。UNISIGN中涉及的付款码更多地与支付宝和微信中的个人收款码类似；从技术角度来讲，也与登录码属于同种类型。因此，本项目将以支付宝及微信个人收款码和登录码中会遇到的安全问题为基础来进行讨论。<br> 

&emsp;&emsp;如果说有什么问题比较常见而且危害极大的话，那么一定是钓鱼二维码。简而言之，钓鱼二维码就是通过一定的方式将原先的二维码进行替换，并诱导用户进行扫描使得用户中招。那么钓鱼二维码会通过什么方式来实现，UNISIGN又该怎么防范呢？

### 跨站请求伪造（Cross-site request forgery，CSRF）攻击

#### 攻击原理
1. 用户访问了一个已注册账户的DApp，并通过扫描二维码登录并进行交易； 
2. DApp验证账户信息，在浏览器中产生cookie（区块链账户不容许私钥存在cookie上）；
3. 黑客找出此DApp没有防御的链接，通过社会工程学伪装一个二维码来诱导用户扫码（如在押注成功之后显示一个二维码并标注“幸运用户：追加押注，压一得二，上不封顶”）；
4.	用户在此DApp中保持登录状态并主动扫描目标二维码，该二维码被扫码后会要求访问处于登录状态的DApp，请求发出一个request；
5.	根据该request要求，浏览器带着步骤2中产生的cookie访问该DApp并夺取对该账户的控制权。<br>

注意：<br>
&emsp;&emsp;该攻击方式不适用所有DApp，可能会遭受CSRF攻击的DApp一般有如下两个特点：<br>
1. 拥有一套独立的账户体系；
2. 不会每一笔交易都验证用户私钥，牺牲部分安全性来换取更快的交易速度。

#### 防御手段
1.	验证HTTP Referer字段<br>
&emsp;&emsp;根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。要防御CSRF攻击，只需要对于每一个二维码中的请求验证其Referer值，如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。
2. 服务器端验证请求的token一致性<br>
&emsp;&emsp;在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中是抵御CSRF攻击的关键。DApp开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。

3. 在HTTP头中自定义属性并验证<br>
&emsp;&emsp;此方法也是使用token并进行验证，和前一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了前一种方法在请求中加入token的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心token会通过Referer泄露到其他网站。

## 拦截二维码传假交易hash
&emsp;&emsp;钓鱼二维码是可以利用现有攻击手段进行攻击的方式，当然也可能会有其他手段来利用二维码实现钓鱼。除此之外，特针对本项目流程中可能出现的拦截二维码传假交易hash问题给出解决方案。

#### 问题
&emsp;正常的流程应该是：<br>
1. 用户在Neuron手机端通过扫描二维码获取API URL信息；
2. 去服务端请求或者直接在二维码中获取交易信息；
3. 用户确认交易信息后支付成功；
4. 然后手机端将hash和状态码返回给服务器端；
5. 服务器端在获得手机端的hash和状态码之后，给前端推送hash值和交易状态。<br>

&emsp;&emsp;但是在实际操作流程中，可能存在用户拦截二维码获取交易信息并向服务器端传递假hash以及成功状态0，这样DApp就会认为交易已经成功，但实际上该交易是无效的。

#### 解决方案
&emsp;&emsp;因为该问题的受害者主要是DApp厂商，所以在扫描二维码获取的API URL信息中也应当包括DApp的相关信息，比如Chain ID等。因此本项目计划设置API Key数据，API Key会与Dapp厂商的清单文件进行注册绑定，传递的假hash值也就不会被DApp验证通过。

注意：<br>
&emsp;&emsp;这一问题的解决将在未来版本中实现。但是因为现有技术并不具备条件利用此问题来攻破本系统，因此在后续版本上线之前也是相对安全的。后续版本也会在近期上线。


